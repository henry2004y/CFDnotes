<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/CFD_Practice/libs/highlight/github.min.css"> <link rel=stylesheet  href="/CFD_Practice/css/franklin.css"> <link rel=stylesheet  href="/CFD_Practice/css/pure.css"> <link rel=stylesheet  href="/CFD_Practice/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/CFD_Practice/assets/favicon.png"> <title>The Discontinuous Galerkin Method</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/CFD_Practice/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/CFD_Practice/chap1/" class=pure-menu-link >Math</a> <li class="pure-menu-item "><a href="/CFD_Practice/chap2/" class=pure-menu-link >Mesh Generation</a> <li class="pure-menu-item pure-menu-selected"><a href="/CFD_Practice/chap4/" class=pure-menu-link >DG</a> <li class="pure-menu-item pure-menu-selected"><a href="/CFD_Practice/Incompressible/" class=pure-menu-link >Incompressible</a> </ul> </div> </div> <div id=main > <div class=header > <h1>The Discontinuous Galerkin Method</h1> <h2>Not just notes</h2> </div> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#1d_scalar_conservation">1D Scalar Conservation</a><li><a href="#1d_advection-diffusion">1D Advection-Diffusion</a><li><a href="#libraries">Libraries</a><li><a href="#code_optimizations">Code Optimizations</a><li><a href="#more_things_to_try">More Things to Try</a></ol></div> <h1 id=one-dimensional_conservation_laws ><a href="#one-dimensional_conservation_laws" class=header-anchor >One-Dimensional Conservation Laws</a></h1> <h2 id=1d_scalar_conservation ><a href="#1d_scalar_conservation" class=header-anchor >1D Scalar Conservation</a></h2> <p>The full Julia implementation can be found at ... Note that when p ≥ 4, the scheme becomes unstable. I wonder what&#39;s the reason behind.</p> <p>Originally I had implemented my own RK4 timestepping method. Inspired by Trixi.jl and the idea of semi-discretization, I managed to use DifferentialEquations.jl directly for timestepping, which is much more robust since it is not limited to one time marching scheme. This is a much more elegant solution, especially for numerical packages.</p> <h2 id=1d_advection-diffusion ><a href="#1d_advection-diffusion" class=header-anchor >1D Advection-Diffusion</a></h2> <h1 id=two-dimensional_conservation_laws ><a href="#two-dimensional_conservation_laws" class=header-anchor >Two-Dimensional Conservation Laws</a></h1> <p>Key points:</p> <ul> <li><p>The Lagrangian basis points in the reference triangle is not the same as quadrature points.</p> <li><p>The area integral quadrature points in the reference triangle are not the same as line integral quadrature points along the triangle edges. See the <a href="https://scicomp.stackexchange.com/questions/27441/line-integral-along-the-edge-of-an-isoparametrically-mapped-triangle">discussion</a>. The integration direction also matters: by convention, counter-clockwise path integral is positive while clockwise path integral is negative. One easy check you can do is to integrate a uniform function along the edge and compare that with the perimeter of the triangle.</p> <li><p>Line integral mapping is error-prone compared with area integral, because you have to take direction and edge lengths into consideration. In area integral from reference element to physical element, you just need to multiply by the determinant of the Jacobian matrix; in line integral, you need to multiply by the line length as well as be careful about whether the quadrature points should go counter-clockwise or clockwise. Generally, we need counter-clockwise quadrature points for the left element of the edge evaluation, and clockwise quadrature points for the right element of the edge evaluation. Maybe there are tricks taking advantage of symmetry since the reference domain in 1D is usually &#91;-1,1&#93;, but I have not had a working version with that yet.</p> <li><p>Pay attention to the necessary order of quadrature rules. In my original Fortran code, when evaluating the edge fluxes I use Gauss-Legendre integral of order <code>2p&#43;1</code>, which may be unnecessarily high given that the evaluated polynomial basis functions do not reach that order. If you happen to use an inapppropriate low order quadrature rule &#40;i.e. Dunuvant points and weights&#41;, you may end up with a singular elemental mass matrix&#33;</p> </ul> <p>For the first time, it took me a month to get working version with Fortran. I generally followed the structure design of BATSRUS, which was a good learning process. I thought at the time that it was clean, well-written and well-documented, until four years later when I tried to rewrite the model in Julia. For the second time, it took me about a week to get a working version with Julia. I spent quite some time reading my own Fortran code &#40;not so easy, even I coded the entire thing myself~&#41;, and found many places that were either wrong &#40;e.g. L2 error computation&#41; or could be improved &#40;e.g. directory checking/creation, variable naming, module structures&#41;. Then it took me a day to optimize the code with 10-20x speed up by removing small temporary array allocations. The profiling results are summarized <a href="https://github.com/henry2004y/CFD/issues/1">here</a>.</p> <p>I do not finish everything in the project:</p> <ul> <li><p>least square projection for initialization is there, but never being tested. However, it is more important to understand why this works and how it works. This leads to the question of how to evaluate the accuracy of finite element solutions. Instead of being more accurate on a certain bunch of points, we may want to be more accurate on the whole domain instead. The least square projection follows the idea that if I generate the solution by minimizing the L2 norm error, then it should provide more accurate solution later on when evaluating the L2 norm error. Fidkowski had some nice comments in the FE section of his AE423 notes.</p> <li><p>Plotting is quite inaccurate in the Julia implementation because for simplicity I only have one averaged value per element. Unlike in Matlab we have this <code>fill/patch</code> method which can draw per element so we can clearly observe the discontinuities, in Matplotlib we only have <code>tricontour</code> or <code>tripcolor</code>. <code>tricontour</code> only accepts nodal values; <code>tripcolor</code> can accept either cell values or node values. The simplest way to get a relatively accurate plot is probably averge the solution on each node and use gradient fill for the elements. It would be even better if I can find a way to plot element-by-element.</p> </ul> <h2 id=libraries ><a href="#libraries" class=header-anchor >Libraries</a></h2> <p><a href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl">MultivariatePolynomials.jl</a>: package for constructing Legendre basis functions. It is not very user-friendly.</p> <p><a href="https://github.com/JuliaAlgebra/TypedPolynomials.jl">TypedPolynomials.jl</a>: for evaluating numerical values of multivariate polynomials at quadrature points.</p> <p><a href="https://github.com/JuliaFEM/FEMQuad.jl">FEMQuad.jl</a>: numerical integration schemes for cartesian and tetrahedron domains. I use it for obtaining Gauss-Legendre integral points in triangles, i.e. Dunavant points.</p> <h2 id=code_optimizations ><a href="#code_optimizations" class=header-anchor >Code Optimizations</a></h2> <p>Even if some programming languages have libraries for polynomials and basis, it is generally not good to evaluate polynomials everytime when you do computations within the time steps. Remember the extremely slow version of 1D shallow-water DG solver implemented with symbolic functions in MATLAB? I tend to write that way the first time because it has a very similar form to the mathematical expression, but in practice, I should not do that.</p> <p>For example, let the coefficients be stored in an array named <code>coef_PVE</code>. To get the density at a point location with basis function <code>ϕ</code> in reference space <code>&#40;ξ, η&#41;</code>,</p> <pre><code class="julia hljs">ρ = sum(coef_PVE[:,ρ_,  k] .* ϕ)(ξ=&gt;x[<span class=hljs-number >1</span>], η=&gt;x[<span class=hljs-number >2</span>])</code></pre>
<p>Alternatively, we can precompute the basis function values at quadrature points and store them as float arrays. Since the unknowns of FEM are multiplier coefficients of basis functions, we can have highly efficient computations of getting physical quantities and evaluating integrals through simple floating point arithmatics:</p>
<pre><code class="julia hljs">ρ = sum(coef_PVE[:,ρ_,   k] .* phi[:,j])</code></pre>
<p>where <code>phi</code> is the precomputed values of basis functions evaluated at quadrature points.</p>
<p>However, since the solutions of finite element methods are functions, in principle we can obtain values at any given location in our simulation domain. When doing visualizations, it may be better to evaluate our solution at more points than the quadrature points used for computation. In this case, we can switch back to the polynomial evaluations.</p>
<p>Furthermore, for a system of equations with multiple variables, we can make evaluation of state variables in element <code>k</code> and quadrature point <code>q</code> into a simple linear algebra</p>
<pre><code class="julia hljs">ρ, ρux, ρuy, ρE = phi[:,q]&#x27; * coef_PVE[:,:,k]</code></pre>
<p>which is equivalent to evaluate each quantity separately, but 2x faster.</p>
<p>Usually you don&#39;t need to worry too much about the temporary scalar allocation within loops; however, it is a good practice to check if you are not sure.</p>
<h2 id=more_things_to_try ><a href="#more_things_to_try" class=header-anchor >More Things to Try</a></h2>
<ul>
<li><p>The code I have now is based on unstructured triangular mesh. It should be pretty easy to convert that to a structured rectangular mesh, with a natural extension of tensor products from 1D.</p>

<li><p>Curved boundary: not so interesting me at the moment because I am not doing high fidelity boundary layer simulations, but may be important if I have a chance to work on that in the future.</p>

<li><p>Diffusion: DG has been practically proved to work well on advection problems, while CG is known to work well on diffusion problems. For fluid simulations, we are more interested in advection than diffusion, but we still need to include the diffusion terms. I need to be more familiar in this treatment.</p>

</ul>
<div class=page-foot >
  <div class=copyright >
    &copy; Hongyang Zhou. Last modified: June 04, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
      </div> 
  </div> 
  <script src="/CFD_Practice/libs/pure/ui.min.js"></script>